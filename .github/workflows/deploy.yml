name: Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-west-2
  PROJECT_NAME: TroutTracker
  STACK_NAME: TroutTracker-Stack

jobs:
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    outputs:
      api_endpoint: ${{ steps.get-outputs.outputs.api_endpoint }}
      frontend_bucket: ${{ steps.get-outputs.outputs.frontend_bucket }}
      cloudfront_id: ${{ steps.get-outputs.outputs.cloudfront_id }}
      feedback_table: ${{ steps.verify-feedback.outputs.table }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Check and cleanup failed stack
        run: |
          echo "Checking stack status..."
          STACK_STATUS=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Stacks[0].StackStatus' \
            --output text 2>/dev/null || echo "NOT_FOUND")
          
          echo "Current stack status: $STACK_STATUS"
          
          if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ]; then
            echo "âš ï¸  Stack is in ROLLBACK_COMPLETE state, deleting..."
            aws cloudformation delete-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            echo "Waiting for stack deletion to complete..."
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            echo "âœ… Stack deleted successfully, ready for fresh deployment"
          elif [ "$STACK_STATUS" != "NOT_FOUND" ] && [[ "$STACK_STATUS" == *"FAILED"* ]]; then
            echo "âš ï¸  Stack is in failed state: $STACK_STATUS"
            echo "Attempting to delete..."
            aws cloudformation delete-stack \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            aws cloudformation wait stack-delete-complete \
              --stack-name ${{ env.STACK_NAME }} \
              --region ${{ env.AWS_REGION }}
            
            echo "âœ… Failed stack deleted"
          else
            echo "âœ… Stack status is OK (${STACK_STATUS}), proceeding with deployment"
          fi

      - name: Deploy CloudFormation stack
        run: |
          aws cloudformation deploy \
            --template-file infrastructure/cloudformation.yaml \
            --stack-name ${{ env.STACK_NAME }} \
            --parameter-overrides \
                GoogleGeocodingApiKey=${{ secrets.GOOGLE_GEOCODING_API_KEY }} \
                ProjectName=TroutTracker \
                EnableCloudFront=true \
            --capabilities CAPABILITY_NAMED_IAM \
            --region ${{ env.AWS_REGION }} \
            --no-fail-on-empty-changeset

      - name: Get stack outputs
        id: get-outputs
        run: |
          API_ENDPOINT=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiEndpoint`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "api_endpoint=$API_ENDPOINT" >> $GITHUB_OUTPUT
          
          FRONTEND_BUCKET=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendBucketName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "frontend_bucket=$FRONTEND_BUCKET" >> $GITHUB_OUTPUT
          
          CLOUDFRONT_ID=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`CloudFrontDistributionId`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          echo "cloudfront_id=$CLOUDFRONT_ID" >> $GITHUB_OUTPUT

      - name: Verify feedback table
        id: verify-feedback
        run: |
          FEEDBACK_TABLE="${{ env.PROJECT_NAME }}-Feedback"
          aws dynamodb describe-table \
            --table-name "$FEEDBACK_TABLE" \
            --region ${{ env.AWS_REGION }} > /dev/null
          echo "table=$FEEDBACK_TABLE" >> $GITHUB_OUTPUT

  deploy-lambda-scraper:
    name: Deploy Scraper Lambda
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: backend/api/requirements.txt
          cache: 'pip'
          cache-dependency-path: backend/scraper/requirements.txt

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Package and deploy Scraper Lambda
        run: |
          cd backend/scraper
          
          # Install dependencies
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt -t .
          
          # Remove unnecessary files to reduce package size
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "test" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type f -name "*.pyo" -delete 2>/dev/null || true
          find . -type f -name "*.dist-info" -delete 2>/dev/null || true
          find . -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
          
          # Create optimized zip package
          zip -r scraper.zip . \
            -x "*.pyc" \
            -x "*__pycache__*" \
            -x "*/tests/*" \
            -x "*/test/*" \
            -x "*.pyx" \
            -x "*.pxi" \
            -x "*.c" \
            -x "*.cpp" \
            -x "*.md" \
            -x "*.txt" \
            -x "requirements.txt" \
            -q
          
          # Check package size
          PACKAGE_SIZE=$(du -h scraper.zip | cut -f1)
          echo "ðŸ“¦ Package size: $PACKAGE_SIZE"
          
          SCRAPER_FUNCTION=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`ScraperFunctionName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          aws lambda update-function-code \
            --function-name $SCRAPER_FUNCTION \
            --zip-file fileb://scraper.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Scraper Lambda deployed successfully"
          
          rm -f scraper.zip

  deploy-lambda-api:
    name: Deploy API Lambda
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Package and deploy API Lambda
        run: |
          cd backend/api
          
          # Install dependencies
          python -m pip install --upgrade pip
          python -m pip install -r requirements.txt -t .
          
          # Remove unnecessary files
          find . -type d -name "tests" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "test" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null || true
          find . -type f -name "*.pyc" -delete 2>/dev/null || true
          find . -type f -name "*.pyo" -delete 2>/dev/null || true
          find . -type d -name "*.dist-info" -exec rm -rf {} + 2>/dev/null || true
          find . -type d -name "*.egg-info" -exec rm -rf {} + 2>/dev/null || true
          
          # Create optimized zip package
          zip -r api.zip . \
            -x "*.pyc" \
            -x "*__pycache__*" \
            -x "*/tests/*" \
            -x "*/test/*" \
            -x "*.md" \
            -q
          
          # Check package size
          PACKAGE_SIZE=$(du -h api.zip | cut -f1)
          echo "ðŸ“¦ Package size: $PACKAGE_SIZE"
          
          API_FUNCTION=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`ApiFunctionName`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          aws lambda update-function-code \
            --function-name $API_FUNCTION \
            --zip-file fileb://api.zip \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… API Lambda deployed successfully"
          
          rm -f api.zip

  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, deploy-lambda-api]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Build frontend
        run: |
          cd frontend
          npm ci
          
          MAPS_KEY="${{ secrets.GOOGLE_MAPS_API_KEY }}"
          if [ -z "$MAPS_KEY" ]; then
            MAPS_KEY="${{ secrets.GOOGLE_GEOCODING_API_KEY }}"
          fi
          
          # Create .env.production
          cat > .env.production <<EOF
          VITE_API_ENDPOINT=${{ needs.deploy-infrastructure.outputs.api_endpoint }}
          VITE_GOOGLE_MAPS_API_KEY=${MAPS_KEY}
          EOF
          
          npm run build

      - name: Upload to S3
        run: |
          aws s3 sync frontend/dist/ s3://${{ needs.deploy-infrastructure.outputs.frontend_bucket }} \
            --delete \
            --cache-control "public, max-age=31536000, immutable" \
            --exclude "index.html" \
            --region ${{ env.AWS_REGION }}
          
          # Upload index.html with different cache settings
          aws s3 cp frontend/dist/index.html s3://${{ needs.deploy-infrastructure.outputs.frontend_bucket }}/index.html \
            --cache-control "public, max-age=0, must-revalidate" \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… Frontend uploaded to S3"

      - name: Invalidate CloudFront cache
        if: needs.deploy-infrastructure.outputs.cloudfront_id != ''
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.deploy-infrastructure.outputs.cloudfront_id }} \
            --paths "/*" \
            --region ${{ env.AWS_REGION }}
          
          echo "âœ… CloudFront cache invalidated"

      - name: Get deployment URLs
        run: |
          FRONTEND_URL=$(aws cloudformation describe-stacks \
            --stack-name ${{ env.STACK_NAME }} \
            --query 'Stacks[0].Outputs[?OutputKey==`FrontendUrl`].OutputValue' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "=========================================="
          echo "ðŸŽ‰ Deployment Complete!"
          echo "=========================================="
          echo "Frontend URL: $FRONTEND_URL"
          echo "API Endpoint: ${{ needs.deploy-infrastructure.outputs.api_endpoint }}"
          echo "Feedback Table: ${{ needs.deploy-infrastructure.outputs.feedback_table }}"
          echo "=========================================="
